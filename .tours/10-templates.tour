{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "10. Templates",
  "steps": [
    {
      "file": "codestar/settings.py",
      "description": "**Templates: The base template and homepage**\n\n**Purpose:**\n- The document provides instructions on creating a Django template.\n- The template mixes static and dynamic HTML.\n- The steps include creating a base.html template for all subsequent templates to inherit from.\n- An index.html template is created for a view listing all posts.\n- This will result in a change in the layout of posts on the home page.\n---\n**Theory: Prev Lesson YouTube**\n\n- **Django Template Language** (*DTL*)\n- **Static Files:**\n    - Files like CSS, JavaScript, or image files.\n    - Typically found in an assets directory in a regular HTML web app but Django requires them to be in a static directory.\n- **Dynamic Files**\n    - Files generated or altered based on user interactions, data from a database, or other dynamic conditions.\n    - Used to display personalised content, process form data or provide interactive features.",
      "line": 115
    },
    {
      "file": "codestar/settings.py",
      "description": "**Templates: The base template and homepage**\n\n**Prepare the project for multiple tempate directories:**\n\n1. In codestar/settings.py, create a TEMPLATES_DIR constant to build a path for our subdirectory 'templates'.\n```\nTEMPLATES_DIR = os.path.join(BASE_DIR, 'templates')\n```",
      "line": 21,
      "selection": {
        "start": {
          "line": 1,
          "character": 1
        },
        "end": {
          "line": 3,
          "character": 58
        }
      }
    },
    {
      "file": "codestar/settings.py",
      "description": "**Templates: The base template and homepage**\n\n**Prepare the project for multiple tempate directories:**\n\n2. Scroll down in the codestar/settings.py file to TEMPLATES and add your newly created TEMPLATES_DIR constant to the list of 'DIRS'.\n\n```\n'DIRS': [TEMPLATES_DIR],\n```",
      "line": 65
    },
    {
      "file": "templates/base.html",
      "description": "**Templates: The base template and homepage**\n\n**Prepare the project for multiple template directories:**\n\n3. Add a new top-level templates directory.\n",
      "line": 1
    },
    {
      "file": "templates/base.html",
      "description": "**Templates: The base template and homepage**\n\n**Create Templates:**\n\n4. Add a new base.html file to your newly created top-level templates directory.\n\n5. Add all the code linked [here](https://github.com/Code-Institute-Solutions/blog/blob/main/08_templates/01_base_template/base.html) to the base.html file.\n",
      "line": 2
    },
    {
      "file": "blog/templates/blog/index.html",
      "description": "**Templates: The base template and homepage**\n\n**Create Templates:**\n\n6. Add a new index.html file to your existing app-level blog/templates/blog directory.\n\n7. Add all the code linked [here](https://github.com/Code-Institute-Solutions/blog/blob/main/08_templates/01_base_template/index.html) to the index.html file.",
      "line": 4
    },
    {
      "file": "blog/views.py",
      "description": "**Templates: The base template and homepage**\n\n**Create Templates:**\n8. Open the blog/views.py file and replace the existing template_name with the new template_name and add a paginate_by into the PostList class-based view.\n**remove:**\n```\ntemplate_name = \"post_list.html\"\n```\n\n**add:**\n```\ntemplate_name = \"blog/index.html\"\npaginate_by = 6\n```\n----\n9. You can now delete the redundant **post_list.html template**, as we've replaced it with the new index.html template.",
      "line": 19
    },
    {
      "file": "static/css/style.css",
      "description": "**Templates: The base template and homepage**\n\n**Create Templates:**\n\n11. Create a top-level static directory with a css directory within it.\n----\n12. Create a style.css file in the css directory.\n----\n13. Add the[CSS code linked here](https://github.com/Code-Institute-Solutions/blog/blob/main/08_templates/01_base_template/style.css) whole project. As you are familiar with CSS and the focus of this project is Django, we will not be going into any detail. CSS for a web framework is the same as for any other web application.\n\n",
      "line": 1
    },
    {
      "file": "codestar/settings.py",
      "description": "**Templates: The base template and homepage**\n\n**Create Templates:**\n14. Open the codestar/settings.py file and build a path for our subdirectory static so we can link to files in the static directory from a template.\n\n```\nSTATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'), ]\n```",
      "line": 133
    },
    {
      "file": "templates/base.html",
      "description": "**Templates: The base template and homepage**\n\n**Create Templates:**\n16. In the base.html, add a link for your custom CSS file css/style.css below all the other CSS files.\n\n```\n<!-- Custom CSS -->\n<link rel=\"stylesheet\" href=\"{% static 'css/style.css' %}\">\n```\n---\n17. Now, return to the homepage in the browser and do a hard refresh to see the CSS styling.\n\nNote: As always, when you have a new working code feature, git add, commit and push to GitHub.\n\n",
      "line": 24
    },
    {
      "file": "templates/base.html",
      "description": "**Templates: Template Inheritance**\n\n**Purpose:**\nDjango's template inheritance allows for the repeated use of a base template, ensuring project consistency and saving time by eliminating repetitive tasks.",
      "line": 4
    },
    {
      "file": "templates/base.html",
      "description": "**Templates: Template Inheritance**\n\n**Challenge & Explanation:**\nLook at the styled blog homepage, as seen in the topic image. Now, open the index.html and base.html files.\n\n1. *Which HTML file contains the header and footer? Which contains the code for the list of blog posts?*\n\n- The base.html file contains the header and footer.\n- The index.html file contains the code to display the list of blog posts.\n----\n2. *Can you identify the special bit of code in base.html that links it to index.html?*\n\nIn base.html, we have the following code\n\n```\n{% block content %}\n    <!-- Content Goes here -->\n{% endblock content %}\n```\n- A block is defined here.\n- The 'base.html' file serves as a skeleton HTML document.\n- The child templates are responsible for filling these blocks with content.\n\n----\n\n3. *What special bits of code in index.html link it to base.html?*\n\nIn index.html, we have two bits of code that link it back to base.html.\n\n```\n{% extends \"base.html\" %}\n{% block content %}\n\n<!-- index.html content starts here -->\nâ€¦\n<!-- index.html content ends here -->\n{% endblock %}\n```\n\n- We begin with the `extends` tag.\n- It shows that `index.html` is a subset of `base.html`.\n- Everything inside our section fills the matching parts in `base.html`.\n- This creates a complete web page.\n---\n# **Theory:**\n---\n\n## **Why inherit?**\n- For single-page projects, writing everything inside one HTML file might seem simpler, as there's no need to worry about blocks and extends.\n- For projects with multiple pages, defining a base HTML page is beneficial for maintaining site consistency.\n- **Consider the `base.html` page as a picture frame. Any picture can be placed inside, but the frame remains the same.**\n- Template inheritance aligns well with the DRY (Don't Repeat Yourself) programming principle.\n- Elements like the header, navigation bar, and footer are common across all pages.\n- By using inheritance, these elements only need to be written once. The content from each page is then injected into named blocks.\n- This approach ensures consistency and saves time.\n----\n\n## **Finding our templates**\n\n### **How does Django know where to find the templates?**\n\n\nThe `TEMPLATES` setting in the `settings.py` file helps Django find templates. It has two main parts:\n\n1. `DIRS`: This is a list showing where Django should look for templates. We add the `TEMPLATES_DIR` to this list, which we define at the start of `settings.py`.\n2. `APP_DIRS`: If this is `True`, Django will look for a `templates` folder in all our app folders.\n\nFor our project, we've set `TEMPLATES_DIR` to point to the `templates` folder in our main directory.\n----\n\n## **Bits about blocks**\nIn Django, `block` and `endblock` tags let you add content in a child template.\n\nHere's how it works:\n\n```bash\n{% block content %}\n    <!-- Add your content here -->\n{% endblock content %}\n\n```\n\nYou give each block a name, like `content` in our example. This is where you put your page content. You can name blocks anything you want. A template can have many blocks, and a child template can choose whether to fill them.\n\nFor example, you might have a `sidebar` block for a side navigation bar. In this project, we only have a `content` block, but you can add more blocks with different names in your projects.\n----\n\n## **Loading more than one block**\nYou don't have to make a new file for every `block` in your main template. For example, in the `sidebar` case, both `content` and `sidebar` would be in one file, `index.html`. When `index.html` is opened, Django fills only the blocks found in the child template. If a block isn't in the child template, Django leaves it blank.\n\nAlso, you can put default content in a block in your main template. If the child template fills that block, the default content gets replaced. For example, you can add this in `base.html`:\n\n```bash\n{% block content %}\n<p>This is my default paragraph</p>\n{% endblock content %}\n\n```\n\n\n\n\n",
      "line": 7
    },
    {
      "file": "blog/templates/blog/index.html",
      "description": "**Templates: Variables and Control Structures**\n\n**Purpose:**\n\n- What is it? This is about variables and control structures.\n- What does it do? It lets us use programming parts in Django templates.\n- Why do I need it? This makes your templates more flexible and react to changing data.\n- You've learned about Django template tags that let a child template draw from a parent. Now, we'll look at ideas more common in regular programming, like variables and control structures.",
      "line": 2
    },
    {
      "file": "blog/templates/blog/index.html",
      "description": "**Templates: Variables and Control Structures**\n\n**Challenge & Explanation:**\n\n## **Part 1: Index.html**\n1. As you look through the code for index.html, you will see some Django Template Language code contained in double braces {{ }} and some contained in a brace and percent sign: {% %}. What do you think the difference between them is?\n\n*There are 2 types of notation:*\n- The double brace notation {{ }} indicates a variable. When the template engine encounters a variable, it evaluates that variable and replaces it with the result. For example, {{ post.author }} will be replaced by the value of the author attribute from the post object.\n- The brace and percentage sign notation, {% %}, is what we call a tag. Tags are more complex than variables. Some of them, like the block tag, allow for text or HTML to be inserted. Others, like the for loop, control flow by performing loops or logical operations.\n----\n2. Look back at the code for index.html. Locate the second row class. Inside there, we have a for loop. What do you think post_list is? Where do you think this value comes from?\n\n*A for loop needs something to iterate over. In this case, the post _ list object. This object is passed into the template by the generic ListView, and contains the contents of the queryset that we defined earlier.*\n----\n3. After we display `post.created_on` and the closing div tags, there is another Django control structure:\n`{% if forloop.counter|divisibleby:3 %}`\nWhat do you think this does? What happens if you change the number 3 to 2?\n\n*This if statement checks to see how many times our for loop has run. If the counter is divisible by three, then it inserts another closing div tag and a new div with the class of row. This is so that we have a maximum of three posts per row on the homepage. If you change that number to 2 and refresh your project, you will see that you have three rows of two posts instead of two rows of three. This is a handy trick to remember when formatting your own list pages. Make sure you put the number back to 3 and save your index.html file before moving on.*\n----\n----\n## **Part 2: base.html**\n1.Now, let's go back to base.html in the top-level templates directory. In the navigation section, you will see an anchor tag with the class of \"navbar-brand\", which links back to the homepage. What do you notice is different about the href? Where do you think the value for 'home' comes from?\n\n*This is a Django Template Language tag. Inside the tag, we have url and a reference to 'home'. The url tag returns an absolute path reference which is a URL without the domain name. It does this, in our example, for the URL named 'home'. Where does it get this name from? Take a look at the blog/urls.py file, and you will see that our main view has the name of home. So, when Django encounters a url tag, it looks up the name of the URL and inserts it for us. We'll explore the benefits of this approach below.*\n----\n2. Scroll down further until you find this code:\n```\n<a class=\"nav-link\n  {% if request.path == home_url %}active{% endif %}\"\n  aria-current=\"page\" href=\"#\">\n```\n**Note:** *The formatting may differ from the layout here. Can you determine what is happening inside the class attribute? How is this connected to what is happening at the top of base.html in this line of code: {% url 'home' as home_url %}.*\n\nLet's start at the top of the file. Here, we use our now familiar url tag. This time, though, we are assigning the 'home' URL to a variable named home_url, which is what the as keyword does. Now, let's return to our if statement. It compares request.path, which is our current URL, with the home_url variable. If they're the same, then it inserts the word active into the class names.\n----\n----\n### **Theory:**\n----\n----\n\n#### **Unpicking the for Loop**\n- 'For' loops are used to iterate through lists, such as our list of posts.\n- HTML is written once, and the loop repeats it as needed.\n- The 'post_list' object is used, which is created by the 'ListView' in our `views.py` file.\n- Django assigns the name 'post_list', based on the model name 'Post' and the view type 'ListView'.\n- During the 'post_list' iteration, the results of each loop are stored in the 'post' variable.\n- This 'post' variable holds a single record from the database.\n- To display the values, the object name and the field name are separated by a dot, like 'post.author'.\n- The variable name 'post' can be any desired name. It could have been written as `{% for p in post_list %}` and `p.author`.\n\n#### **Unpicking the if statement**\n\n- The Django Template Language `if` tag functions the same as an if statement in Python.\n- If the current `request.path` equals the variable established at the top of `base.html`, the text `active` is added to the class.\n- `Request.path` is a string representing the full path to the requested page, excluding the domain.\n- Cannot nest a tag within another tag, so the `url` output was assigned to a variable.\n- Many Django Template Language tags require an `{% endfor %}` or `{% endif %}` tag. If these aren't included, Django will return an error when it attempts to render the template.\n\n#### **The benefits of the url tag**\n- The `url` tag is useful for avoiding repetition.\n- You won't need to edit every page with a static URL if your project's URL scheme changes.\n- Use named URLs in your `urls.py` and template files to prevent broken URLs.\n- This section is detailed, so ensure you understand before moving forward.",
      "line": 1
    },
    {
      "file": "blog/templates/blog/index.html",
      "description": "**Templates: Variables and Control Structures**\n\n**Test Your Knowledge & Solution:**\n\n### **Part 1: Adding data**\n\n1. Open the index.html file and locate where the {{ post.title }} variable is displayed. We want to display the post's excerpt now too. Add a paragraph with the class of card-text beneath the h2 element.\n\nThe relevant part of your index.html code, should now look like this:\n```\n<a href=\"#\" class=\"post-link\">\n    <h2 class=\"card-title\">{{ post.title }}</h2>\n    <p class=\"card-text\">{{ post.excerpt }}</p>\n</a>\n```\n----\n",
      "line": 21,
      "selection": {
        "start": {
          "line": 1,
          "character": 1
        },
        "end": {
          "line": 5,
          "character": 28
        }
      }
    },
    {
      "file": "templates/base.html",
      "description": "**Templates: Variables and Control Structures**\n\n**Test Your Knowledge & Solution:**\n\n### **Part 2: Adding a url **\n1. Switch back to base.html and scroll down to the navigation section where we analysed the if statement in the class. You'll notice that the href for this link is simply set to #. Use the url tag like we did earlier to insert the home URL.\n\nThe relevant part of your base.html code should now look like this:\n```\n<a class=\"nav-link\n  {% if request.path == home_url %}active{%endif%}\"\n  aria-current=\"page\" href=\"{% url 'home' %}\">\n```\n\nNote: As you only have 1 nav bar link here, you won't be able to see much of a difference. This text is black, whereas links for inactive pages will be grey.\n",
      "line": 42
    },
    {
      "file": "blog/views.py",
      "description": "**Templates: Pagination**\n\n**Purpose:**\n\n**Pagination:** *is a tool that splits content into separate pages. It makes it easier for users to read and manage long lists of content.*\n\n## **What is Pagination?**\n\nThink of pagination as a book's table of contents, but for your Django project. Just like how a table of contents helps you jump to different chapters in a book, Pagination helps break down your online content into different \"pages\".\n\n## **Why use Pagination?**\n\nImagine if a book didn't have a table of contents or page numbers, and you had to flip through each page to find a chapter. Frustrating, right? This is exactly what pagination helps to avoid in your Django Project. It helps manage and organize your content, making it easier for users to find what they need.\n\n## **How does Django use Pagination?**\n\nIn a Django project, pagination is like an automatic page-maker. It takes all your content, and then breaks it down into separate \"pages\" for you. This makes viewing and navigating through your Django project much simpler and user-friendly.\n\n",
      "line": 22
    },
    {
      "file": "blog/views.py",
      "description": "**Templates: Pagination**\n\n**Explanation & Test Your Knowledge:**\nThis code snippet controls the **pagination setting** in the `Postlist view`.\n",
      "line": 21
    },
    {
      "file": "blog/templates/blog/index.html",
      "description": "**Templates: Pagination**\n\n**Explanation & Test Your Knowledge:**\n\n*4. Where is the code that creates the Next button? Try to find it in index.html. Why is there no Next button on the last page?*\n\n### **The 'Next' button's code is in 'index.html'. It shows up in two steps:**\n\n1. If there are more than 6 posts, the `is_paginated` value becomes `True`. If it's `True`, the buttons are shown.\n\n2. Inside the `if` statement, there's another `if` statement to decide if the 'Next' button should be shown. If the remaining posts are less than or equal to the `paginate_by` setting (meaning it's the last page), Django makes `page_obj.has_next` `False`. This hides the button. ",
      "line": 41
    },
    {
      "file": "blog/templates/blog/index.html",
      "description": "**Templates: Pagination**\n\n**Explanation & Test Your Knowledge:**\n\n*Put the value back to 6. When you go onto the second page of blog posts, what changes are there to the URL? Where does Django get the code for the URL?*\n\n```\n<a href=\"?page={{ page_obj.next_page_number }}\"\n  class=\"page-link\">\n```\n\n- When you switch to the second page, Django adds `?page=2` to the URL.\n- This helps the `ListView` show the second page of posts.\n- The `ListView` takes care of all the pagination work.\n- The URL is made by the Next button's anchor tag.\n\n**Note:** \n\n*The formatting may differ from the layout here.*\n\n## **More Info:**\n - [The Page Object](https://learn.codeinstitute.net/courses/course-v1:CodeInstitute+FSD101_WTS+2/courseware/56a2da0940b4411d8a38c2b093a22c60/c592ed45498e440587b764e29891b2fc/)\n\n\n\n\n",
      "line": 45
    },
    {
      "file": "codestar/settings.py",
      "description": "**Templates: Deployment with static files**\n\n**Purppose:**\n\n- Static files are needed to make your app work when you put it online.\n- They handle the non-changing parts of your app.\n- These files are gathered in a 'staticfiles' directory to help your online app run correctly.\n- Deploying with static files ensures your app looks just as good online as it does on your computer.\n- A Python package called WhiteNoise is used for this purpo\n\n----\n\n## **Install and setup the Python Packages:**\n\n**Note:** *This package lets your Heroku app share its own static files, so you don't need to use outside file hosting services like a content delivery network (CDN)*\n\n1. **Terminal Command: Python Package**\n```\npip3 install whitenoise~=5.3.0\n```\nWhiteNoise is a Python package that simplifies working with static files in your web applications. You can think of it like a librarian for your web app's files. When you use WhiteNoise, it's like telling this librarian to manage your app's bookshelf. It organizes all the static 'books' (like images, CSS, and JavaScript files) so that they're easy to find and access, which helps your web application run smoothly and look great. To use WhiteNoise, you would install it using the command pip3 install whitenoise~=5.3.0.\n\n2. **Save Requirements.txt**\nAdd the package to your requirements.txt file.\n\n```\npip3 freeze --local > requirements.txt\n```\n\n\n",
      "line": 18,
      "selection": {
        "start": {
          "line": 13,
          "character": 6
        },
        "end": {
          "line": 13,
          "character": 44
        }
      }
    },
    {
      "file": "codestar/settings.py",
      "description": "**Templates: Deployment with static files**\n\n**Install and setup the Python Packages:**\n\n3. Wire up WhiteNoise to Django's MIDDLEWARE in the **codestar/settings.py** file.\n\n**Note:** *The WhiteNoise middleware must be placed directly after the Django `SecurityMiddleware`.*\n\n```\n'whitenoise.middleware.WhiteNoiseMiddleware',\n\n```",
      "line": 52
    },
    {
      "file": "codestar/settings.py",
      "description": "**Templates: Deployment with static files**\n\n**Create a staticfiles directory and collect the static files**\n\n4. Also, in the **codestar/settings.py** file, add a `STATIC_ROOT path`.\n```\nSTATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')\n```\n\n5. Run the **collectstatic command** in the terminal to collect the static files into a **staticfiles directory**.\n\n```\npython3 manage.py collectstatic\n```\n**Note:** *The command has created a staticfiles directory that you can see in the left-hand explorer panel. We will explain this in detail in the next topic.*",
      "line": 135,
      "selection": {
        "start": {
          "line": 13,
          "character": 1
        },
        "end": {
          "line": 13,
          "character": 32
        }
      }
    },
    {
      "file": "codestar/settings.py",
      "description": "**Templates: Deployment with static files**\n\n**Deployment**\n\n6. From the **terminal**, check the *Python version* used in your IDE.\n```\npython3 -V\n```\n\n7. Look up the [supported runtimes](https://devcenter.heroku.com/articles/python-support#specifying-a-python-version) here and copy the runtime closest to the one used in your IDE.\n\nIn this case, my IDE used 3.9.17, so I will choose python-3.9.18 as it is also a revision of version 3.9. Heroku periodically updates the supported runtimes.\n\n----\n**Runtime:**\n- A runtime is akin to a stage for a play.\n- *The stage provides the right environment for actors to perform; similarly, the runtime provides the right environment for a program to run.*\n- The runtime is the software that helps your program (comparable to the script of the play) interact with the hardware (analogous to the stage props and lighting).\n- Choosing a \"runtime\" for your program is similar to choosing the right stage for your play.\n----\n",
      "line": 136
    },
    {
      "file": "codestar/runtime.txt",
      "description": "**Templates: Deployment with static files**\n\n**Deployment**\n\n\n8. Add a **runtime.txt** file to your app's root directory.\n\n*A runtime file specifies an exact Python version number to use in Heroku.*\n\n9. Add the Python version you copied from the list of supported runtimes to your **runtime.txt** file.\n\n\n",
      "line": 1
    },
    {
      "file": "codestar/settings.py",
      "description": "**Templates: Deployment with static files**\n\n**Deployment**\n\n10. Set DEBUG to False. Git add, commit and push the code to GitHub.\n```\ngit add --all\ngit commit -m \"enable serving of static files\"\ngit push origin main\n```\n**git add --all** *The git add --all command is like packing everything in your room into a moving box. It tells Git to get all the changes you made in your project (like new, changed, or removed files) ready for the next 'commit'. A 'commit' is like taping the box shut and writing on it, so it's ready to be moved (or in Git, saved).*\n\n11. Go to the **Heroku dashboard** for your deployed project. To review the look and layout of your hosted app, first, click **Open app**.\n\n12. Return to the Heroku dashboard, and click on the **Settings tab** and the **Reveal config vars** button. Remove the **DISABLE_COLLECTSTATIC key/value pair**.\n\n**Note:** *This environment variable prevented collectstatic from running on deploy up till now, but as static files are set up, we can remove this.*\n\n13. Click on the **Deploy tab**, scroll down, choose the main branch and press **Deploy Branch**.\n\n14. Open the Heroku-hosted app to see that it is now styled just like the local development app.\n\n### **Remember:** *Set **DEBUG** to True in settings.py in readiness for the next topic.*",
      "line": 31
    },
    {
      "file": "static/js/ script.js",
      "description": "**Templates: What are static files?**\n\n***Purpose:**\n\n- *Static files are simple files*\n    1. admin\n    2. css\n    3. summernote / staticfiles\n- They allow Django to deliver simple files\n- They are needed to share CSS, JavaScript and static images through Heroku\n- We have learned how to get Django to share these simple files\n- We need to understand more about what simple files are, why we need a special package to share them, and why we can't just have everything on Herok\n\n-----\n## **Theory**\n-----\n\n### **1. What is the static files directory?**\n\n- Django collects all static files (like CSS, JavaScript or images) from each installed application in a directory called `staticfiles` when you run `collectstatic`.\n- This is set in the `STATIC_ROOT` setting in **settings.py**.\n- Whenever you add or modify a static file, make sure to run `collectstatic`.\n- You can upload the `staticfiles` directory to GitHub and deploy it to Heroku.\n- With the help of a tool called `whitenoise`, Django will serve all our CSS, JavaScript, and images from this directory.\n- Heroku reminds us to run `collectstatic` whenever we make a change to make our work easier.\n\n### **2. Disabling COLLECTSTATIC**\n- Heroku is a platform that simplifies handling Django projects.\n- Heroku runs `collectstatic` automatically.\n- `collectstatic` aids with static files.\n- *If Heroku's `DISABLE_COLLECTSTATIC` setting is enabled, it doesn't run `collectstatic` during project deployment.*\n- The lack of styles in the admin dashboard on Heroku is due to this.\n- The build logs show this process.\n- *REMOVING `DISABLE_COLLECTSTATIC` allows Heroku to manage static files on deployment.*\n- *No need to run `collectstatic` unless not using Heroku or `DEBUG` is False.*\n- `whitenoise` is needed because Django's static file management is not suitable for live environments.\n- Django's `runserver` is not secure or scalable enough for live use.\n- In a live setting, `gunicorn` is used for the project and `whitenoise` for static files.\n\n### **3. Middleware**\n\n- Django's middleware is a helper that operates between a web request and response.\n- Middleware can modify both the request and response.\n- It improves the request, response, and view, comparable to how extra toppings enhance a burger.\n- The Whitenoise middleware specifically alters the response to retrieve static files from the 'staticfiles' directory.\n- These static files are then provided when a user visits the site.\n\n**Note:** *Middleware often needs to be **loaded in a particular order**. The documentation for a piece of middleware will tell you where it needs to be in the MIDDLEWARE list in settings.py.*\n\n### **4. And finally, runtime.txt**\n\n- Heroku requires a `runtime.txt` file to identify the correct Python version for the project.\n- This file ensures consistency between your computer and the Heroku server.\n- Always refer to Heroku's guides for the supported Python versions before deploying your project on Heroku.",
      "line": 1
    },
    {
      "file": "static/js/ script.js",
      "description": "**Templates: What are static files?**\n\n***Test Your Knowledge & Solutions**\n\n1. Inside your static directory, create a new directory called js; inside that, create a file called script.js.\n\n2. Add a console.log statement to print a message to the console.\n    *static/js/script.js*\n```\nconsole.log(\"Life, The Universe and Everything!\");\n```",
      "line": 2
    },
    {
      "file": "templates/base.html",
      "description": "**Templates: What are static files?**\n\n***Test Your Knowledge & Solutions**\n\n3. Above the closing `</body>` tag in **base.html** add a *new script element*.\n\n4. Using the same static Django Template Language tag that we use for the css/style.css, *set the src to open your **js/script.js** file*.\n\n5. Run your project in your development environment, and navigate to the homepage. Using Developer Tools, check to see that the message is logged to the console.\n\n- Your message should be visible in the browser console both locally and after you have deployed.\n\n**Note:** *If you get an error in the console saying that script.js could not be loaded, ensure that you have saved the file and that it is in the correct directory*\n",
      "line": 82
    }
  ]
}