{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "9. Rich Text Reload",
  "steps": [
    {
      "file": "codestar/settings.py",
      "description": "**Rich Text & Reload: Admin Panel Power-Up**\n\n**Purpose:**\n- We'll enhance the admin panel for easier blog post addition and edits using **Summernote**, a robust text editor.\n- **Summernote** transforms the admin page to allow rich text formatting like headings and paragraphs, unlike Django's plain text. **It embeds a **'what you see is what you get' (WYSIWYG)** editor**\n- **Summernote** provides a 'what you see is what you get' editor for a live preview of content, simplifying editing.\n- We'll modify the post form using Django's features so that the slug auto-fills from the title, and posts can be sorted by status.",
      "line": 37
    },
    {
      "file": "codestar/settings.py",
      "description": "**Rich Text & Reload: Admin Panel Power-Up**\n\n**Install and Wire Up the Packages:**\n\n1. **Terminal Command**: *django-summernote package*\n```\npip3 install django-summernote~=0.8.20.0\n```\n\n2. Add the django-summernote package to the **requirements.txt file**\n```\npip freeze > requirements.txt\n``",
      "line": 57
    },
    {
      "file": "codestar/settings.py",
      "description": "**Rich Text & Reload: Admin Panel Power-Up**\n\n**Install and Wire Up the Package:**\n\n3. **Open the *codestar/settings.py* file**\n\nAppend django_summernote to the **INSTALLED_APPS**.\n```\n'django_summernote',\n```\n\n**Note:**\n *The dash in the package name is replaced with an underscore in the INSTALLED_APPS list.Remember the quotes and trailing comma.*",
      "line": 45
    },
    {
      "file": "codestar/urls.py",
      "description": "**Rich Text & Reload: Admin Panel Power-Up**\n\n**Install and Wire Up the Packages:**\n\n3. **Open the `codestar/urls.py` file** \n    \n    Include the Summernote urlpattern.\n    - As `django_summernote` is an app, we need to include its `urls.py` file.\n    - Remember to add the trailing comma after the path.\n    - The path should look like this: `path('summernote/', include('django_summernote.urls')),`.\n    - A reminder: In the future, as we add more paths, it's a good idea to sort the string paths alphabetically. Keep the empty string path at the end.",
      "line": 24
    },
    {
      "file": "blog/admin.py",
      "description": "**Rich Text & Reload: Admin Panel Power-Up**\n\n**Update the Blog App to use Summernote**\n\n5. Open the **blog/admin.py** file and import the class `SummernoteModelAdmin` from the **django_summernote/admin.py** file.\n\n```\nfrom django_summernote.admin import SummernoteModelAdmin\n```\n\n**Note:** *The ready-made **SummernoteModelAdmin** class defines the text editor, enabling you to access its functionality in the admin panel for your posts.*",
      "line": 3
    },
    {
      "file": "blog/admin.py",
      "description": "**Rich Text & Reload: Admin Panel Power-Up**\n\n**Update the Blog App to use Summernote**\n\n6. *Below the imports*, but *above the existing registered models*, in the **blog/admin.py file**, add a class named `PostAdmin`\n\nThis code will give your admin panel greater functionality and clarity. We'll discuss this in more detail soon.\n\n```\nclass PostAdmin(SummernoteModelAdmin):\n\n    list_display = ('title', 'slug', 'status')\n    search_fields = ['title']\n    list_filter = ('status',)\n    prepopulated_fields = {'slug': ('title',)}\n    summernote_fields = ('content',)\n```\n\n**Note:** *In the prepopulated_fields, the tuple containing the single value of title requires a trailing comma.*",
      "line": 5
    },
    {
      "file": "blog/admin.py",
      "description": "**Rich Text & Reload: Admin Panel Power-Up**\n\n**Update the Blog App to use Summernote**\n\n7. **Add** an `@admin.register()` decorator above the `PostAdmin` class and pass in the Post model as an argument.\n\n**Note:**\n- The **decorator is a method** used for registering a class.\n- This method differs from the standard model registration done earlier.\n- By using a class and registering it with a decorator, the models' appearance on the admin site can be customized.\n- This approach is more Python-friendly.",
      "line": 5
    },
    {
      "file": "blog/admin.py",
      "description": "**Rich Text & Reload: Admin Panel Power-Up**\n\n**Update the Blog App to use Summernote**\n\n8. Now we have a decorator above the PostAdmin class; delete the existing Post model registration.\n**Remove:**\n```\nadmin.site.register(Post)\n```",
      "line": 15
    },
    {
      "file": "blog/admin.py",
      "description": "**Rich Text & Reload: Admin Panel Power-Up**\n\n**Update the Blog App to use Summernote**\n\n9. Apply the migrations for the django_summernote app.\n\n**Terminal Command:**\n```\npython3 manage.py migrate\n```",
      "line": 17
    },
    {
      "file": "codestar/settings.py",
      "description": "**Rich Text & Reload: Admin Panel Power-Up**\n\n**View the changes to the Admin Page**\n\n10. Run the Django server and open in a browser\n    ```\n    python manage.py runserver\n    ```\n    **Note:** *Set to* `DEBUG = True`\n    \n11. Append `/admin` to the URL in the browser and log in with your *superuser credentials.*\n\n---\n\n**Django Admin Panel:**\n\n12. Click on Posts to see the new filter By status you added using the PostAdmin class on the right side.\n\n13. Click +Add to add a new post.\n\n14. Create a Published post using the example blog text content provided.\n\n15. Use the GUI menu to format the plain text content.\n\n    Make every heading bold.\n    Change the font of the code snippet to Courier New..\n    Save the post.\nNote: You won't be able to see this formatted text in the blog yet, as you have yet to create the view. However, you'll be able to see this formatted text any time you open the admin panel to create or edit a post.",
      "line": 48
    },
    {
      "file": "blog/admin.py",
      "description": "**Rich Text & Reload: Admin Panel Customisation**\n\n**Purpose:**\n**WHAT IS IT?\nIt's an improvement to the admin panel.**\n\n**WHAT DOES IT DO?**\n\n**It improves the admin panel's ease of use.**\n\n**WHY DO I NEED IT?**\n\n**It makes adding blog posts easier.**\n\n**Last time, you learned to change the post form in the admin area. Now, we'll make more changes to this form to make it easier for the superuser who adds blog posts.**",
      "line": 18
    },
    {
      "file": "blog/admin.py",
      "description": "**Rich Text & Reload: Admin Panel Customisation**\n\n**Challenge & Explanation:**\n\n- Run Django server from the command line\n\t```\n\tpython manage.py runserver \n\t```\n- Open it in the browser\n- Append `/admin` to the URL and log in as the **superuser**\n- Navigate to `/admin/blog/post/`\n- Open the **blog/admin.py** file in your IDE",
      "line": 19
    },
    {
      "file": "blog/admin.py",
      "description": "**Rich Text & Reload: Admin Panel Customisation**\n\n**Challenge & Explanation:**\n\n**Part 1: Comparing code with output**\n\n1. Can you compare the features in the PostAdmin class to the updates in the admin panel design? To answer this, please check these two pages in the admin panel:\n\n**a. The Posts page (three attributes).**\n    You can see the changes we made to summernote on two pages:\n\n    **a. Post Page:**\n\n    ![Post Page Diagram](assets/images/post_change.png)\n\n- The `list_display` attribute sets the fields to be seen on the Posts page of the admin dashboard, serving as the headers for the posts table.\n- The `search_fields` attribute speeds up searches by limiting the fields to be searched, a helpful feature when dealing with many posts.\n- The `list_filter` attribute adds a filter to the admin page sidebar for post status, letting the superuser sort posts by draft or published status.\n---\n\n    **b. The Add Post page (two attributes):**\n\n    ![Post Page Diagram](assets/images/add_post_page.png)\n\n- The `prepopulated_fields` attribute automatically creates a slug based on the input title.\n- The `summernote_fields` attribute applies the rich-text editor to the content, replacing the old textarea input.",
      "line": 20
    },
    {
      "file": "blog/admin.py",
      "description": "**Rich Text & Reload: Admin Panel Customisation**\n\n**Challenge & Explanation:**\n\n2. **Part 2: Further Modifying the Admin Panel**\n\nIn **blog/admin.py**, append a new value of created_on to the list_display attribute. What do you think will change in the admin panel with this new list value appended? Save your file and reload the admin panel Posts page to check if your prediction is correct.\n\n```\nlist_display = ('title', 'slug', 'status', 'created_on')\n```\n- `created_on` is added to the `list_display` attribute.\n- This change will show this field on the admin Posts page.\n- A new column titled CREATED ON will be made.\n- This new column will be to the right of the Select post to change table.\n- The dates will be shown in this new column.\n",
      "line": 8
    },
    {
      "file": "codestar/settings.py",
      "description": "**Rich Text & Reload: Admin Panel Customisation**\n\n**Challenge & Explanation:**\n\n3. **Part 3: Installing Django-Summernote**\nAfter the installation of django-summernote, we made some updates to the admin.py file. Could you remember the other three steps required to get the package operational? To find the changes in the code, consider using the search tool of your code editor and search for \"summernote\".\n\n**After installing django-summernote, you also added it to:**\n    1. The `INSTALLED_APPS` in **settings.py**,.\n    2. The urlpatterns path in **urls.py**.\n    3. `python3 manage.py migrations`\n\n**Note:** *The other Python packages installed to date have only required to be added to the requirements file. The additional steps here are closer to what we would do with a Django app. Essentially django_summernote is a Django app with urls.py, admin.py and migrations files.*\n",
      "line": 45
    },
    {
      "file": "codestar/settings.py",
      "description": "**Rich Text & Reload: Admin Panel Customisation**\n\n**Challenge & Explanation: Theory**\n\n**1. The power of admin panel customisation:**\n\n- The Django admin site allows trusted users to manage the project's content.\n- It's a tool for internal use within the web app, not for customers.\n- The admin site is designed to be practical for technical users.\n- You can customize the admin page to simplify it for your superusers.\n- In the context of a blog, this could mean:\n    - Showing only necessary fields\n    - Enabling quick searches on titles\n    - Filtering by published status\n    - Automatically filling the slug field\n    - Enabling rich-text content entry\n---\n\n**2. Installing django-summernote:**\n- Adding `'django_summernote'` to the `INSTALLED_APPS` makes it a Django app.\n- This allows the `python3 manage.py migrate` command to see the app and create new django_summernote database tables.\n- Including the Summernote `urlspaths` in the `codestar/urls.py` file links the `django_summernote` app to the `codestar` project.\n- The django-summernote python package was added as `'django_summernote'` to the `INSTALLED_APPS.`\n- A common pattern is that a dash in a package name changes to an underscore in a Django app name.\n---\n\n**3. Admin Panel Access:**\n- The admin panel is for the superuser, a trusted individual who may not have technical knowledge.\n- Strong passwords are crucial for superusers as they can create, read, update, and delete all database records, accessing everything except users' encrypted passwords.\n- Customizing the admin panel aims to simplify its usage for the superuser.\n- For developers, customizing the admin panel can help demonstrate a project to non-technical team members, clients, or potential employers.\n---\n\n**4. Who cannot acess the admin page**\n- Don't give admin access to everyday readers or commenters to prevent data tampering.\n- We will create forms for users to comment on blog posts.\n- Users can fully interact with their comments.\n- Only a superuser can fully interact with blog posts.\n---\n\n",
      "line": 47
    },
    {
      "file": "blog/admin.py",
      "description": "**Rich Text & Reload: Admin Panel Customisation**\n\n**Test Your Knowledge:**\nOpen the blog/admin.py file and add the following functionality.\n\n1. *Enable faster `'content'` searches.*\n2. *Modify the right-hand filter panel to match the image.*\n\n---\n**Solution:**\n```\nclass PostAdmin(SummernoteModelAdmin):\n\n    list_display = ('title', 'slug', 'status', 'created_on')\n    search_fields = ['title', 'content']\n    list_filter = ('status', 'created_on',)\n    prepopulated_fields = {'slug': ('title',)}\n    summernote_fields = ('content',)\n```\n\n",
      "line": 9
    },
    {
      "file": "blog/fixtures/posts.json",
      "description": "**Rich Text and Reload: Adding More Posts***\n\n**Purpose:**\n\n*WHAT DOES IT DO?*\nStores pre-written data for a database in the same format as the relevant database table(s).**\n\n*WHY DO I NEED IT?*\nTo quickly populate a database table with multiple entries.\n\n- Django's 'fixtures' will be discussed in this guide.\n- So far, blog posts have been manually added through the admin panel for testing.\n- Many posts will soon be required for lessons like pagination, which is time-consuming to add individually.\n- Fixtures assist in transferring data into databases.\n- A fixture can be thought of as a custom data file for your database.\n- It can be used to save data or to populate a database for development.\n- A JSON fixture will be used, but Django also supports XML and YAML.\n- Steps to get started will be provided below.\n",
      "line": 1
    },
    {
      "file": "blog/fixtures/posts.json",
      "description": "**Rich Text and Reload: Adding More Posts***\n\n**Adding Fixtures:**\n\n1. Open your project in your IDE and add a directory within your blog app named fixtures.\n\n2. Within the blog/fixtures directory, create a new file named posts.json\n\n\n3. Copy and paste the JSON from this source file to your posts.json file.\n\n4. Now load the data to the database table using the fixture name of posts. Django knows where to look for the file, as it is stored in the fixtures directory by default, e.g. blog/fixtures/posts.json\n\n**Terminal Command:**\n```\npython3 manage.py loaddata posts\n```\n\n\n\n",
      "line": 2,
      "selection": {
        "start": {
          "line": 1,
          "character": 1
        },
        "end": {
          "line": 3,
          "character": 21
        }
      }
    },
    {
      "file": ".gitignore",
      "description": "**Rich Text and Reload: Adding More Posts***\n\n**Adding Fixtures:**\n\n\n5. You can now add `blog/fixtures/` to the **.gitignore** file.\n\n**Note:** *You can keep the directory locally, as this technique will be helpful in the future if you run into database errors.*",
      "line": 10
    },
    {
      "file": ".gitignore",
      "description": "**Rich Text and Reload: Adding More Posts**\n\n**View Data:**\n\n6. Run the Django server in the workspace terminal and open the browser. Append **/admin** to the browser URL. Log in to the admin dashboard with the superuser credentials (if you are not already).\n\n\n\n7. Click on Posts and view the newly added posts.\n\n**Note:** \n\n*The newly added posts appear to have been created on a date before the ones you added yourself. The created_on date for the newly added posts is the date in the JSON file, not the current date. Therefore, they appear older than the posts you added from the admin panel.*\n---\n**Review:**\n\n- This section explains how to use fixtures to add posts, a different method from using the admin panel.\n- Fixtures are useful in Django development when you need a lot of data for testing or showing a code's result.\n- If an error wipes your database table, fixtures can help refill it quickly.\n- Developers can use this method to fill a database with fake data to show a working project to co-workers, clients, or potential employers.",
      "line": 11
    }
  ]
}