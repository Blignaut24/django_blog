{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "8. Views Part 1",
  "steps": [
    {
      "file": "blog/urls.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Purpose:**\nIn these text-based steps, we'll create the main page for our blog using Django's generic views. Think of these as pre-existing building blocks: instead of making everything from scratch, Django has pre-written classes we can inherit from to build a class-based view. These classes handle everyday tasks for us.\n\n**Preparatory Steps:**\n1. Github Kanban: Move the View paginated list of posts user story into In Progress.\n2. In the **blog** directory, create a new Python file named `urls.py`.\n*This file is where we'll list our blog app-specific URLs.*\n\n",
      "line": 1,
      "selection": {
        "start": {
          "line": 1,
          "character": 1
        },
        "end": {
          "line": 6,
          "character": 23
        }
      }
    },
    {
      "file": "codestar/urls.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Preparatory Steps:**\n3. Open the `codestar/urls.py` file and delete the blog_views import. \n```\nfrom blog import views as blog_views\n```\n\n*We don't need it anymore because our blog now has its own URL file. We'll explain this in more detail in an upcoming topic*",
      "line": 19
    },
    {
      "file": "codestar/urls.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Preparatory Steps:**\n4. Ensure that include is imported from django.urls by appending it after path\n```\nfrom django.urls import path, \n```",
      "line": 18
    },
    {
      "file": "codestar/urls.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Preparatory Steps:**\n\n5. Also, replace the existing blog/ urlpattern with a new empty string urlpattern.\n\nThis pattern tells Django to look in the blog app URL file for any blog urlpatterns.\n\n~~path(\"blog/\", blog_views.blog,name='blog'),~~\n\n```\npath(\"\", include(\"blog.urls\"), name=\"blog-urls\"),\n```\n\n",
      "line": 23
    },
    {
      "file": "codestar/urls.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Preparatory Steps:**\n\n6. Next, we need to create a templates directory in the blog app, with another directory nested within, named blog. Django expects this file structure. To create the directory structure, use the following command in the terminal:\n\n**Terminal Command:**\n```\nmkdir -p blog/templates/blog\n```\n- The terminal command creates a directory structure for your Django project.\n- It creates a new directory named 'blog'.\n- Within 'blog', it creates another directory named 'templates'.\n- Inside 'templates', another directory named 'blog' is created.\n- This structure is useful for organizing the HTML templates of your Django application.",
      "line": 26
    },
    {
      "file": "blog/templates/blog/post_list.html",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Preparatory Steps:**\n\n7. In this new blog/templates/blog directory, create a new HTML file named `post_list.html` and paste the\n[HTML code provided here](https://github.com/Code-Institute-Solutions/blog/blob/main/06_views_part1/02_building_homepage/post_list.html)\n\n*Don’t worry about any of the templating language in the provided HTML code; this explanation is in an upcoming lesson.*",
      "line": 1
    },
    {
      "file": "blog/views.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Preparatory Steps:**\n\n8. In the blog/views.py file, delete the existing blog function-based view and the HttpResponse import.\n\n~~from django.http import HttpResponse~~\n\n# Create your views here.\n~~def blog(request):~~\n\n    ~~return HttpResponse(\"Hello Blog!\")~~",
      "line": 2
    },
    {
      "file": "blog/views.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Create a class-based view:**\n\n9. In the blog/views.py file, import generic from django.views and import the Post model.\n```\nfrom django.views import generic\nfrom .models import Post\n```",
      "line": 3
    },
    {
      "file": "blog/views.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Create a class-based view:**\n\n10. In the blog/views.py file, create a class-based view named PostList that inherits from the generic.ListView class to display all your posts.\n\n```\nclass PostList(generic.ListView):\n    model = Post\n```\n",
      "line": 11
    },
    {
      "file": "blog/urls.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Create a class-based view:**\n\n11. In the new empty blog/urls.py file, import the views file and path.\n\n```\nfrom . import views\nfrom django.urls import path\n```\n",
      "line": 1
    },
    {
      "file": "blog/urls.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Create a class-based view:**\n\n12. Below the imports, add a urlpattern for your *PostList* class-based view named home.\n\nAs the view is a class, you need an *as_view()* method, unlike the previous function-based view.\n\n```\nurlpatterns = [\n    path('', views.PostList.as_view(), name='home'),\n]\n```\n\n\n",
      "line": 4
    },
    {
      "file": "blog/urls.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n\n**Create a class-based view:**\n\n13. Run the server and view the new homepage. All posts in your database are displayed.",
      "line": 7
    },
    {
      "file": "blog/views.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Create a class-based view:**\n\n14. The advantage to using class-based generic views is that they are very terse, i.e. you do not need to add the HTML template name or list which posts you want to see. Let’s add these optional lines of code in the PostView class, ready for you to modify in the next topic.\n\n**Note:** *We can remove the model = Post as it is made redundant by the queryset explicitly stating all posts are displayed.*\n```\nclass PostList(generic.ListView):\n    ~~model = Post~~\n    queryset = Post.objects.all()\n    template_name = \"post_list.html\"\n```\n",
      "line": 13
    },
    {
      "file": "blog/views.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Create a class-based view:**\n\n15. Run the server and view the new homepage. As you can see, there is no change. Again, all the posts in your database are displayed.\n",
      "line": 15
    },
    {
      "file": "codestar/settings.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Deployment:**\n\n16. Open the **codestar/settings.py** file and replace DEBUG=True with `DEBUG=False`.",
      "line": 30
    },
    {
      "file": "codestar/settings.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Deployment:**\n\n17. Git add, commit and push your code.\n*generic post view*",
      "line": 31,
      "selection": {
        "start": {
          "line": 5,
          "character": 2
        },
        "end": {
          "line": 5,
          "character": 19
        }
      }
    },
    {
      "file": "codestar/settings.py",
      "description": "**Building the Homepage with Django Generic Views**\n\n**Deployment:**\n\n18. Do a manual deployment on Heroku. When the build is complete, you should see all of your posts on the home page of your Heroku app.\n\n**Note:** *Remember to return to your workspace and open the **codestar/settings.py** file. Change the value of **DEBUG back to True**, as this will ensure that you get detailed errors to ease debugging during local development.*",
      "line": 32
    },
    {
      "file": "blog/views.py",
      "description": "**Views Part 1: Inside the LIst View**\n\n**Purpose: ListView**\n\nWHAT DOES IT DO?\n*It makes it easy to list things from a database.*\n\nWHY IS IT USEFUL?\n*It helps show blog posts in a list.*",
      "line": 16
    },
    {
      "file": "blog/views.py",
      "description": "**Views Part 1: Inside the LIst View**\n\n**Challenge:**\n\nIn views.py, change all() to `filter(author=1)` on the `queryset` line\n\n**Explanation:**\n- Change `all()` to `filter(author=1)` in the `queryset` line to filter the database.\n- This shows only the data from the author with ID 1.\n- Django's `User` model assigns every user a unique ID, also known as the primary key (PK).\n- The first user (superuser) gets the PK of 1.\n- Each new user gets the next number in line. For example, the second user gets the PK of 2.\n\n**Analogue:**\nImagine you're in a library full of books written by many authors. You want to read books by only one specific author. The command 'filter(author=1)' is like telling the librarian, \"I only want books by Author 1.\" In this scenario, 'author=1' refers to a unique identifying number (like a library card number) given to each author. The first author who registered in the library got the number 1. The next author got the number 2, and so on. So, when you ask for 'author=1', you get books from the very first author who registered.\n\n**Expected Outome**\nIf you have blog posts written by the admin superuser, i.e. author = 1, these will be the only posts appearing on the page. *If you don't have any posts written by the admin superuser, then you will only see a heading that says Posts list.*\n\n",
      "line": 14
    },
    {
      "file": "blog/views.py",
      "description": "**Views Part 1: Inside the LIst View**\n\n**Theory:**\n\n1. ### Generic views\n\n- Django's generic views help display data quickly from a database.\n- They allow the creation of pages that display lists, such as blog posts, products, or orders.\n- These views automate much of the work, saving time and effort.\n- However, they offer limited options for modifications.\n- For more complex or specific requirements, it can be better to use a regular Django view and modify it for the project.\n\n2. ### Understanding Generic Views and Templates in Django\n\n*Think about generic views and templates in Django like a recipe. Just as a recipe gives you step by-step instructions to prepare a dish, a generic view in Django provides a pre-written view for common tasks like displaying a list of objects from your database. It's a ready-to-use solution.*\n\n*Templates in Django are like the presentation of your dish. They define how your data (or dish) should look when served on the webpage (or plate). Just as you can have a default way to plate a dish, Django can automatically guess the template name based on certain conventions. But if you want to present your dish differently, you can choose a different plate (or template) by defining it in `template_name`, just like you may choose to serve your dish on a different style of plate for special occasions.*\n\nYou might have seen that not having template_name = \"post_list.html\" doesn't change the output. That's because Django's general view can guess the template name. It uses a specific naming rule for this.\n\nTake a look at this code snippet to understand better:\n\n```\nclass PostList(generic.ListView):\n    queryset = Post.objects.filter(author=2)\n    # template_name = \"post_list.html\"\n```\n\nIn this example, `post` is the model name and `list` refers to the type of generic view we're using. So, Django automatically expects a template named `post_list.html`.\n\nIf you rename the template and refresh the page, Django will give a template error. If you make this change, don't forget to rename it back to `post_list.html`.\n\nBut, Django also lets us use a different template name by assigning it to `template_name`, as shown in our code sni\n\n3. ### What is a queryset?\n\n*A queryset is like a net that you cast out into a sea of data. If you specify model = Post, it's like casting a net that catches all types of fish called 'Post'. It brings back every 'Post' fish in the sea. Now, this line can be changed to queryset = Post.objects.all(), which does the same thing. It's like commanding the net to bring back all 'Post' fish. However, using Post.objects to create a queryset is like using a more advanced net. It allows you to add filters, a level of customization that isn't possible with the simple model = Post line. It's like saying, \"bring back all 'Post' fish, but only the ones that are red,\" offering you more control over what you catch.*\n\n- When creating a view, a queryset is first made.\n- If `model = Post` is used, Django uses all `Post` records in our `ListView`.\n- A queryset is a group of records from your database.\n- The `model = Post` line fetches all records from the `Post` model, like all blog posts.\n- This line can be changed to `queryset = Post.objects.all()`, which performs the same function. The `all()` method retrieves all objects, or records, from the Post model.\n- Using `Post.objects` to create a queryset allows the addition of filters, a level of customization that isn't possible with the simple `model = Post` line.\n\n\n4. ### Adding Filter\n\nIn Django, a filter works like a coffee filter, letting only certain things through. For example, we ask Django to only let posts with the author field set to 1 through. This blocks all other posts. It's a strong way to search the database.\n\nAnother handy tool is order_by, which lets us arrange our records in a specific order. For example, to show all posts from earliest to latest, we use:\n\n```\nclass PostList(generic.ListView):\n    queryset = Post.objects.all().order_by(\"created_on\")\n\n```\n\nTo sort from most recent to earliest - a logical order for blog posts - we just put a minus sign in front of the field name.\n\n```\nclass PostList(generic.ListView):\n    queryset = Post.objects.all().order_by(\"-created_on\")\n\n```\n\nAlso, it's important to know that the order_by method can be used together with filters.\n",
      "line": 16
    },
    {
      "file": "blog/views.py",
      "description": "**Views Part 1: Inside the LIst View**\n\n**Solution:**\n```\nclass PostList(generic.ListView):\n    queryset = Post.objects.filter(status=1)\n    template_name = \"post_list.html\n```\nThis means that we can now leave some posts in Draft while we finish them, and they will not show up on the live blog.\n\nAdd, commit and push your code to GitHub before continuing.",
      "line": 18
    }
  ]
}